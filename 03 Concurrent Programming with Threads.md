# Concurrent Programming with Threads
# 基于线程的并发编程

到目前为止，我们已经看到了两种创建并发逻辑流的方法。
 - 在第一种方法中，我们为每个流使用了单独的进程。内核会自动调度每个进程. 而每个进程有它自己的私有地址空间，这使得流共享数据很困难。
 - 在第二种方法中，我们创建自己的逻辑流，并利用 I/O 多路复用来显式地调度流。因为只有一个进程，所有的流共享整个地址空间。
 - 本节介绍第三种方法——基于线程，它是这两种方法的混合。

线程（`thread`）就是运行在进程上下文中的逻辑流。在本书里迄今为止，程序都是由每个进程中一个线程组成的。但是现代系统也允许我们编写一个进程里同时运行多个线程的程序。线程由内核自动调度。每个线程都有它自己的线程上下文（`thread context`），包括一个唯一的整数线程 ID（`Thread ID`，TID）、`栈`、`栈指针`、`程序计数器`、`通用目的寄存器和条件码`。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。

基于线程的逻辑流结合了基于进程和基于 I/O 多路复用的流的特性。
同进程一样，线程由内核自动调度，并且内核通过一个整数 ID 来识别线程。
同基于 I/O 多路复用的流一样，多个线程运行在单一进程的上下文中，因此共享这个进程虚拟地址空间的所有内容，包括它的代码、数据、堆、共享库和打开的文件。

# 线程执行模型
多线程的执行模型在某些方面和多进程的执行模型是相似的。

思考图 12-12 中的示例。每个进程开始生命周期时都是单一线程，这个线程称为主线程（`main thread`）。在某一时刻，主线程创建一个对等线程（`peer thread`），从这个时间点开始，两个线程就并发地运行。

最后，因为主线程执行一个慢速系统调用，例如 `read` 或者 `sleep`，或者因为被系统的间隔计时器中断，控制就会通过上下文切换传递到对等线程。
对等线程会执行一段时间，然后控制传递回主线程，依次类推。

在一些重要的方面，线程执行是不同于进程的。因为一个线程的上下文要比一个进程的上下文小得多，线程的上下文切换要比进程的上下文切换快得多。

另一个不同就是线程不像进程那样，不是按照严格的父子层次来组织的。和一个进程相关的线程组成一个对等（线程）池，独立于其他线程创建的线程。

主线程和其他线程的区别仅在于它总是进程中第一个运行的线程。

对等（线程）池概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止。另外，每个对等线程都能读写相同的共享数据。

----------------------------------------------------------------------------------------------------
这段描述提供了一个关于多线程和多进程执行模型的比较，以及线程在操作系统中的行为和特性。我将逐点解释以便更加通俗易懂：

### 多线程与多进程的相似之处

1. **并发执行：** 无论是多线程还是多进程，它们都能实现任务的并发执行。这就像是在一家办公室里，不同的人（进程或线程）同时处理不同的工作。
2. **生命周期：** 每个进程开始时都是单线程的（就像一个人开始一个新工作），然后可能创建一个或多个对等线程（比如雇佣更多的人来帮助完成工作）。

### 多线程的独特之处

1. **轻量级的上下文切换：** 线程之间的上下文切换比进程间的切换要快得多。这就像在办公室里，一个人切换到不同的任务（线程切换）通常比换一个完全不同的工作场所（进程切换）要快和容易。
2. **非层次结构：** 线程不像进程那样有严格的父子关系。这意味着在同一个进程中的所有线程（想象为一个团队里的成员）都是对等的，没有严格的上下级关系。
3. **共享数据：** 线程可以共享相同的数据（就像团队成员共享办公室资源），而进程之间的数据共享通常更加复杂。

### 对等线程池的影响

1. **线程间的互动：** 在一个线程池中，任何线程都可以结束或等待其他线程。这就像一个团队中的任何成员都可以请求其他成员完成任务或等待他们完成任务。
2. **共享数据的风险：** 由于所有线程都能访问相同的数据，这就增加了数据冲突的风险。就像一个办公室里，如果大家都可以随意使用同一台打印机，可能就会出现使用冲突。

### 结论

多线程提供了一种在同一个进程内部高效并发执行多个任务的方式。与多进程相比，它们更轻量级，上下文切换更快，但也带来了数据共享和管理上的挑战。了解和掌握这些特性是进行有效的多线程编程的关键。
----------------------------------------------------------------------------------------------------

# Posix 线程

Posix 线程（Pthreads）是在 C 程序中处理线程的一个标准接口。它最早出现在 1995 年，而且在所有的 Linux 系统上都可用。
`Pthreads` 定义了大约 60 个函数，允许程序*创建*、*杀死*和*回收线程*，与*对等线程安全地共享数据*，还可以*通知对等线程系统状态的变化*。

----------------------------------------------------------------------------------------------------
POSIX（Portable Operating System Interface）标准是一组由 IEEE（电气和电子工程师协会）开发的标准，用于确保不同计算系统之间的兼容性。
POSIX 标准的主要目的是提供一个统一的操作系统接口，使得软件开发者能够在不同的硬件和操作系统平台上开发应用程序，而无需对每个平台做大量的修改。

POSIX 标准包含了多个方面，主要包括：

1. **系统调用和库函数**：定义了一组标准的系统调用和库函数，用于文件操作、进程控制、线程管理、内存分配等。
2. **命令行和实用程序**：规定了一组标准的命令行工具和实用程序，例如 `ls`、`grep`、`awk` 等。
3. **Shell 脚本语言**：定义了 Shell 脚本的标准语法和行为，以确保脚本在不同的 UNIX 系统上能够以相同的方式运行。
4. **用户和组管理**：规定了用户账户和组的管理方式。

POSIX 标准对 UNIX 和类 UNIX 系统（如 Linux、BSD、macOS）有着重要影响，它使得在这些系统上开发的软件具有更高的可移植性和互操作性。
通过遵守 POSIX 标准，软件开发者可以确保他们的应用程序在各种符合标准的系统上能够顺利运行。
----------------------------------------------------------------------------------------------------

~~~c
#include "csapp.h"
void *thread(void *vargp);

int main()
{
    pthread_t tid;
    Pthread_create(&tid, NULL, thread, NULL);
    Pthread_join(tid, NULL);
    exit(0);
}

void *thread(void *vargp) /* Thread routine */
{
    printf("Hello, world!\n");
    return NULL;
}
~~~

主线程创建一个对等线程，然后等待它的终止。
对等线程输岀 “`Hello, world!\n`” 并且终止。
当主线程检测到对等线程终止后，它就通过调用 exit 终止该进程。

这是我们看到的第一个线程化的程序，所以让我们仔细地解析它。
线程的代码和本地数据被封装在一个线程例程（`thread routine`）中。
正如第二行里的原型所示，每个线程例程都以一个通用指针作为输入，并返回一个通用指针。
如果想传递多个参数给线程例程，那么你应该将参数放到一个结构中，并传递一个指向该结构的指针。
相似地，如果想要线程例程返回多个参数，你可以返回一个指向一个结构的指针。

第 4 行标出了主线程代码的开始。主线程声明了一个本地变量 `tid`，可以用来存放对等线程的 ID（第 6 行）。
主线程通过调用 `pthread_create` 函数创建一个新的对等线程（第 7 行）。当对 `pthread_create` 的调用返回时，主线程和新创建的对等线程同时运行，并且 tid 包含新线程的 ID。通过在第 8 行调用 `pthread_join`，主线程等待对等线程终止。
最后，主线程调用 `exit`（第 9 行），终止当时运行在这个进程中的所有线程（在这个示例中就只有主线程）。

第 12 ~ 16 行定义了对等线程的例程。它只打印一个字符串，然后就通过执行第 15 行中的 `return` 语句来终止对等线程。

# 创建线程

线程通过调用 pthread_create 函数来创建其他线程。

~~~c
#include <pthread.h>
typedef void *(func)(void *);

int pthread_create(pthread_t *tid, pthread_attr_t *attr,
                   func *f, void *arg);

// 若成功则返回 0，若出错则为非零。
~~~

`pthread_create` 函数创建一个新的线程，并带着一个输入变量 `arg`，在新线程的上下文中运行线程例程 `f`。
能用 `attr` 参数来改变新创建线程的默认属性。改变这些属性已超出我们学习的范围，在我们的示例中，总是用一个为 NULL 的参数来调用 `pthread_create` 函数。

当 `pthread_create` 返回时，参数 tid 包含新创建线程的 ID。
新线程可以通过调用 `pthread_self` 函数来获得它自己的线程 ID。

~~~c
#include <pthread.h>

pthread_t pthread_self(void);

// 返回调用者的线程 ID。
~~~

# 终止线程

一个线程是以下列方式之一来终止的：
 - 当顶层的线程例程返回时，线程会隐式地终止。
 - 通过调用 `pthread_exit` 函数，线程会显式地终止。如果主线程调用 pthread_exit，它会等待所有其他对等线程终止，然后再终止主线程和整个进程，返回值为 thread_return。

~~~c
#include <pthread.h>

void pthread_exit(void *thread_return);

// 从不返回。
~~~

 - 某个对等线程调用 Linux 的 exit 函数，该函数终止进程以及所有与该进程相关的线程。
 - 另一个对等线程通过以当前线程 ID 作为参数调用 pthread_Cancel 函数来终止当前线程。

~~~c
#include <pthread.h>

int pthread_cancel(pthread_t tid);

// 若成功则返回 0，若出错则为非零。
~~~

----------------------------------------------------------------------------------------------------
`pthread_cancel` 函数提供了一种机制，允许一个线程请求取消另一个线程的执行。这种设计的主要原因包括：

1. **协作多任务处理**：在多线程环境中，可能需要一个线程来监控或协调其他线程的工作。例如，如果一个线程正在执行一个耗时的任务，另一个线程可能需要终止它，以便程序能够响应某个紧急事件或用户操作。

2. **资源管理和异常处理**：如果一个线程发现某种异常情况（如资源不足、无法满足的依赖等），它可能需要终止其他线程。这有助于有效地管理资源和处理错误情况。

3. **优雅的退出和清理**：`pthread_cancel` 允许线程在被取消时执行清理操作。通过使用线程的取消点（特定的函数调用，在其中线程可以被安全地取消），线程在结束前可以释放资源、关闭文件句柄等，从而避免资源泄露。

4. **改善程序响应性和性能**：在某些情况下，一个长时间运行的线程可能不再需要继续其工作（例如，用户请求已改变或更高优先级的任务出现）。能够取消这样的线程可以提高程序的响应性和整体性能。

5. **控制和终止后台操作**：在很多应用中，后台线程用于执行如日志记录、数据加载等任务。当这些操作不再需要时，使用 `pthread_cancel` 可以优雅地终止这些后台操作。

尽管 `pthread_cancel` 提供了强大的控制能力，但它的使用需要谨慎，因为不当的取消可能导致资源泄露、数据不一致或其他并发问题。因此，设计良好的多线程程序通常会小心使用这种机制，并确保线程能够安全地响应取消请求。
----------------------------------------------------------------------------------------------------

# 回收已终止线程的资源

线程通过调用 pthread_join 函数等待其他线程终止。

~~~c
#include <pthread.h>

int pthread_join(pthread_t tid, void **thread_return);

// 若成功则返回 0，若出错则为非零。
~~~

pthread_join 函数会阻塞，直到线程 tid 终止，将线程例程返回的通用 (void*) 指针赋值为 thread_return 指向的位置，然后回收已终止线程占用的所有内存资源。

注意，和 Linux 的 wait 函数不同，pthread_join 函数只能等待一个指定的线程终止。没有办法让 pthread_wait 等待任意一个线程终止。这使得代码更加复杂，因为它迫使我们去使用其他一些不那么直观的机制来检测进程的终止。实际上，Stevens 在【110】中就很有说服力地论证了这是规范中的一个错误。

----------------------------------------------------------------------------------------------------
`pthread_join` 函数是 POSIX 线程（pthread）库中的一个重要组件，用于等待指定线程的终止。它的行为确实与 Linux 的 `wait` 函数有所不同，这在多线程编程中引入了一些复杂性。以下是对这种差异及其产生的影响的详细说明：

### pthread_join 的行为

- **线程等待**：`pthread_join` 用于阻塞调用线程，直到指定的线程（通过 `pthread_t` 类型的参数表示）终止。
- **返回值获取**：如果非空，`pthread_join` 将目标线程的退出状态（即线程函数返回的值）存储在 `thread_return` 指针指向的位置。
- **资源回收**：它还负责回收已终止线程所使用的所有系统资源。

### 与 Linux wait 函数的比较

- **目标差异**：Linux 的 `wait` 函数是用于进程的，它可以等待任何子进程结束，并回收资源。而 `pthread_join` 是专门为线程设计的，只能等待一个特定的线程。
- **灵活性差异**：`wait` 可以等待任何一个子进程结束，而 `pthread_join` 缺乏这种灵活性，因为它只能针对一个特定的线程。

### 引入的复杂性

- **监控多个线程**：如果你有多个并发运行的线程，并且需要等待它们中的任何一个结束，那么你不能像使用 `wait` 那样简单地调用 `pthread_join`。
- **额外的同步机制**：你可能需要使用其他同步机制（如条件变量、信号量或事件）来检测线程何时结束。

### Stevens 对此的评论

- 在《UNIX 网络编程》一书中，W. Richard Stevens 指出，这种设计限制了 `pthread_join` 的灵活性，并可能导致编写多线程程序时需要采用更复杂的同步和协调机制。

### 结论

尽管 `pthread_join` 在线程同步和资源管理方面发挥着关键作用，但其设计决定使得在某些情况下处理线程终止比处理进程终止更为复杂。这要求程序员在设计和实现多线程程序时采用更加周密的策略和技术。
----------------------------------------------------------------------------------------------------


# 分离线程

*在任何一个时间点上，线程是可结合的（`joinable`）或者是分离的（`detached`）。*
一个可结合的线程能够被其他线程收回和杀死。在被其他线程回收之前，它的内存资源（例如栈）是不释放的。
相反，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。

默认情况下，线程被创建成可结合的。
为了避免内存泄漏，每个可结合线程都应该要么被其他线程显式地收回，要么通过调用 pthread_detach 函数被分离。

~~~c
#include <pthread.h>

int pthread_detach(pthread_t tid);

// 若成功则返回 0，若出错则为非零。
~~~

pthread_detach 函数分离可结合线程 tid。线程能够通过以 pthread_self() 参数的 pthread_detach 调用来分离它们自己。

尽管我们的一些例子会使用可结合线程，但是在现实程序中，有很好的理由要使用分离的线程。

例如，一个高性能 Web 服务器可能在每次收到 Web 浏览器的连接请求时都创建一个新的对等线程。
因为每个连接都是由一个单独的线程独立处理的，所以对于服务器而言，就很没有必要（实际上也不愿意）显式地等待每个对等线程终止。
在这种情况下，每个对等线程都应该在它开始处理请求之前分离它自身，这样就能在它终止后回收它的内存资源了。

----------------------------------------------------------------------------------------------------
在多线程编程中，区分可结合（joinable）和分离（detached）线程的机制是非常重要的，因为它涉及到线程管理、资源回收和程序的性能优化。
以下是为什么要设计这种机制的几个原因：

1. **资源管理**：可结合线程在终止时不会自动释放其资源（如栈内存），它们需要由其他线程通过 `pthread_join` 显式回收。
这允许创建线程的程序收集线程的返回状态，并进行适当的清理。然而，在某些情况下，等待线程结束并回收其资源可能是不必要或不切实际的。

2. **性能优化**：对于某些应用程序（如高性能服务器）而言，可能会频繁地创建和销毁大量线程。
在这种情况下，对每个线程进行 `pthread_join` 调用可能会引入显著的性能开销和复杂性。分离线程允许线程结束时自动清理资源，从而减轻了对性能的影响，并简化了线程管理。

3. **简化设计**：在某些设计中，线程可能不需要与其他线程进行直接通信或同步。这些线程可以被设计为“火并忘记”（*fire-and-forget*）模式，一旦启动，它们就独立运行并在完成后自动退出。分离线程提供了这种设计的便利。

4. **避免内存泄漏**：如果一个可结合线程结束了它的执行但没有被 `pthread_join`，它的资源（如栈）不会被释放，可能会导致内存泄漏。通过允许线程被分离，系统可以确保线程资源在结束时被自动释放。

5. **提高系统的可伸缩性**：在高负载系统中，如Web服务器，可能同时存在大量活动线程。分离线程模式允许这些线程独立终止和清理，提高了系统的可伸缩性和响应能力。

总之，可结合和分离线程的概念提供了灵活的线程管理策略，允许程序员根据应用程序的特定需求和性能目标来选择最合适的线程管理机制。

## 通俗解释
在多线程编程中，有两种类型的线程：可结合线程和分离线程。这两种类型的线程主要区别在于它们如何处理自己的结束和资源回收。

1. **可结合线程**：想象一下，你让朋友去做一项任务，但是你需要他们完成后回来向你报告。
在这种情况下，你会等待他们回来，听他们的报告，并且清理他们完成任务后留下的任何东西。
这就像可结合线程，它们在完成工作后不会立即消失。
相反，创建它们的程序需要等待它们完成，获取它们的结果，并且清理它们使用的资源（比如内存）。

2. **分离线程**：现在想象另一种情况，你让朋友去做另一项任务，但这次你不需要他们回来报告。他们只需要自己去做，并且自行处理所有后续事宜。
这就像分离线程，它们在完成任务后会自动清理自己使用的资源并结束，而不需要创建它们的程序来做任何事情。

在一些情况下，比如一个忙碌的网站服务器，它可能会创建成百上千个线程来处理用户请求。
如果这些线程都是可结合的，服务器就需要跟踪并清理这些线程，这可能会非常复杂并且影响性能。
但如果这些线程是分离的，它们就可以在完成任务后自动消失，这样服务器就不需要担心它们了。

因此，根据线程的具体用途和需要，选择正确的线程类型（可结合或分离）是很重要的。这能帮助程序更有效地管理资源，提高性能，同时也简化了代码的复杂性。
----------------------------------------------------------------------------------------------------

# 初始化线程

`pthread_once` 函数允许你初始化与线程例程相关的状态。

~~~c
#include <pthread.h>

pthread_once_t once_control = PTHREAD_ONCE_INIT;

int pthread_once(pthread_once_t *once_control,
                 void (*init_routine)(void));

// 总是返回 0。
~~~

`once_control` 变量是一个全局或者静态变量，总是被初始化为 `PTHREAD_ONCE_INIT`。
当你第一次用参数 once_control 调用 pthread_once 时，它调用 init_routine，这是一个没有输入参数、也不返回什么的函数。
接下来的以 once_control 为参数的 pthread_once 调用不做任何事情。
无论何时，当你需要动态初始化多个线程共享的全局变量时，pthread_once 函数是很有用的。我们将在 12.5.5 节里看到一个示例。

----------------------------------------------------------------------------------------------------
`pthread_once` 函数是 POSIX 线程库中用于确保某个初始化操作只执行一次的机制。
这在多线程环境中非常有用，尤其是在你需要初始化多个线程共享的全局资源时。让我用一个更简单的方式来解释这个概念。

假设你有一个全局资源或变量，这个资源在整个程序运行期间只需要被初始化一次，无论你创建了多少个线程。例如，这可以是一个数据库连接、一个文件句柄，或者任何其他类型的全局设置。

在多线程程序中，如果多个线程尝试同时初始化这个全局资源，可能会导致问题，比如资源冲突或重复初始化。

这里就是 `pthread_once` 发挥作用的地方：

- **`once_control` 变量**：这是一个全局或静态变量，用于跟踪特定的初始化函数是否已经被调用。这个变量应该被初始化为 `PTHREAD_ONCE_INIT`。

- **`pthread_once` 函数**：当你想要执行某个初始化操作时，你会调用 `pthread_once`，并传递两个参数：`once_control` 变量和一个初始化函数 `init_routine`。

- **如何工作**：
  - 在程序的任何地方第一次调用 `pthread_once` 时，它将执行 `init_routine` 函数，进行必要的初始化。
  - 如果之后在程序的其他地方（可能在不同的线程中）再次调用 `pthread_once` 并传递相同的 `once_control` 变量，`init_routine` 将不会被再次执行。这保证了初始化代码只执行一次。

这种机制非常有用，因为它提供了一种线程安全的方式来初始化多个线程共享的资源。你不需要担心多线程环境下的初始化问题，比如竞态条件或重复初始化。通过使用 `pthread_once`，你可以确保不管有多少个线程，初始化代码只会被执行一次。
----------------------------------------------------------------------------------------------------

# 基于线程的并发服务器

~~~c
#include "csapp.h"

// Function declarations
void echo(int connfd);
void *thread(void *vargp);

int main(int argc, char **argv)
{
    int listenfd, *connfdp;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    pthread_t tid;

    // Check if the correct number of command-line arguments are passed
    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }

    // Open a listening socket on the specified port
    listenfd = Open_listenfd(argv[1]);
    
    // Infinite loop to continuously accept client connections
    while (1) {
        clientlen = sizeof(struct sockaddr_storage);
        connfdp = Malloc(sizeof(int));
        // Accept a client connection
        *connfdp = Accept(listenfd, (SA *) &clientaddr, &clientlen);
        // Create a new thread for each client connection
        Pthread_create(&tid, NULL, thread, connfdp);
    }
}

/* Thread routine to handle client connection */
void *thread(void *vargp)
{
    int connfd = *((int *)vargp); // Extract connection file descriptor
    Pthread_detach(pthread_self()); // Detach the thread for independent operation
    Free(vargp); // Free allocated memory for connection file descriptor
    echo(connfd); // Process client request
    Close(connfd); // Close client connection
    return NULL;
}
~~~

整体结构类似于基于进程的设计。主线程不断地等待连接请求，然后创建一个对等线程处理该请求。
虽然代码看似简单，但是有几个普遍而且有些微妙的问题需要我们更仔细地看一看。

第一个问题是当我们调用 pthread_create 时，如何将已连接描述符传递给对等线程。最明显的方法就是传递一个指向这个描述符的指针，就像下面这样

~~~c
connfd = Accept(listenfd, (SA *) &clientaddr, &clientlen);
Pthread_create(&tid, NULL, thread, &connfd);
~~~

然后，我们让对等线程间接引用这个指针，并将它赋值给一个局部变量，如下所示

~~~c
void *thread(void *vargp) {
    int connfd = *((int *)vargp);
    .
    .
    .
}
~~~

然而，这样可能会出错，因为它在对等线程的赋值语句和主线程的 `accept` 语句间引入了竞争（`race`）。
如果赋值语句在下一个 accept 之前完成，那么对等线程中的局部变量 connfd 就得到正确的描述符值。
然而，如果赋值语句是在 accept 之后才完成的，那么对等线程中的局部变量 connfd 就得到下一次连接的描述符值。
那么不幸的结果就是，现在两个线程在同一个描述符上执行输入和输出。
为了避免这种潜在的致命竞争，我们必须将 accept 返回的每个已连接描述符分配到它自己的动态分配的内存块，如第 20 ~ 21 行所示。我们会在 12.7.4 节中回过来讨论竞争的问题。

另一个问题是在线程例程中避免内存泄漏。既然不显式地收回线程，就必须分离每个线程，使得在它终止时它的内存资源能够被收回（第 31 行）。
更进一步，我们必须小心释放主线程分配的内存块（第 32 行）。

====================================================================================================
Q: 在图 12-5 中基于进程的服务器中，我们在两个位置小心地关闭了已连接描述符：父进程和子进程。然而，在图 12-14 中基于线程的服务器中，我们只在一个位置关闭了已连接描述符：对等线程。为什么？

因为线程运行在同一个进程中，它们都共享相同的描述符表。无论有多少线程使用这个已连接描述符，这个已连接描述符的文件表的引用计数都等于 1。
因此，当我们用完它时，一个 close 操作就足以释放与这个已连接描述符相关的内存资源了。
====================================================================================================

